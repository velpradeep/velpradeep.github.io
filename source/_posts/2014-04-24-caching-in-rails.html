---
layout: post
title: "Caching in Rails"
date: 2014-04-24
comments: false
---

<div class='post'>
<script>  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');    ga('create', 'UA-51531085-1', 'velpradeep.blogspot.in');   ga('send', 'pageview');  </script><div dir="ltr" style="text-align: left;" trbidi="on"><div>This Post I am going to explain how to achieve the caching mechanism in Rails</div><div><br /></div><div>There are three types of caching techniques</div><div><ol style="text-align: left;"><li><span style="color: red;">Page Caching</span></li><li><span style="color: red;">Action Caching</span></li><li><span style="color: red;">Fragment Caching (Default in rails)</span></li></ol><div><b>Rails 4&nbsp;</b></div></div><div>&nbsp; <b>&nbsp; Static page caching and action caching is removed </b>from <b>core in &nbsp;Rails 4.0</b></div><div><br />If the user wants to enable &nbsp;<b>page and action caching</b>, you will need to add<b> actionpack-page_caching</b> and <b>actionpack-action_caching </b>to your Gemfile.(removed from core in Rails 4.0)</div><div><br /></div><div><b>Note</b><br />&nbsp;Rails caching is <b>disabled </b>by default in the <b>development </b>environment. Make sure you have below the parameter value below set to true in your Rails app config file.<br /><br />#Inside config/environments/development.rb<br /><b>config.action_controller.perform_caching = true</b><br /><b><br /></b><b>Rails caching is enabled in production mode by default.</b><br /><b><br /></b><span style="color: blue;"><b>Page Caching :</b></span><br />In Rails Page Caching, whenever a request is sent to the server, the Rails server would check for the cached page and if that exists it would be served.<br />&nbsp;If it does not exist, Rails server generates the page &amp; cache it. Hence the Rails app won’t have to generate it again during the next request.<br /><br />Page caching is an approach to caching where the entire action output of is stored as a HTML file that the web server can serve without going through Action Pack.<br />Real time Usage in applications<br /><br />Content management systems -- including weblogs and wikis -- have many pages that are a great fit for this approach, but account-based systems where people log in and manipulate their own data are often less likely candidates.<br /><br /><br />Example:<br /><br /><b><span style="color: #cc0000;">class HomeController &lt; ApplicationController</span></b><br /><b><span style="color: #cc0000;">&nbsp; caches_page :index</span></b><br /><span style="color: #cc0000;"><b><br /></b><b>&nbsp; def index</b></span><br /><span style="color: #cc0000;"><b><br /></b><b>&nbsp; end</b></span><br /><b><span style="color: #cc0000;">end</span></b><br /><b><br /></b>To expire the cache when an update is made, we will have to call<br /><br />an <b>expire_page </b>helper method.<br /><br /><b><span style="color: #cc0000;">def update</span></b><br /><b><span style="color: #cc0000;">&nbsp; &nbsp; &nbsp; &nbsp;expire_page :action =&gt; index</span></b><br /><b><span style="color: #cc0000;">end</span></b><br /><br />Here it is assumed that update action is being called when the page is updated. expire_page inside the action makes sure the cached page is purged &amp; new cached page is created during the next call to profile action.<br />This type of caching in Rails is lightning fast, but one main disadvantage of this is that this can’t be used for caching every page. As the requests don’t go to the Rails app, the authentication and access restrictions using before_filter won’t work if page caching is used.<br /><br />The above example is probably the wrong usage of the Rails page cache. You can see that page served by ‘profile’ action has dependency on the current_user (assume it to be logged in user).<br /><br /><br />Let’s say user_1 is the first user to view the page. The page will be generated &amp; cached with contents for user_1 . If user_2 tries to go to his profile page, he will see user_1 content on it. This is plain wrong &nbsp;.</div><div><br /></div><div><br /></div><div><br /></div></div></div>
